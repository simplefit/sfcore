# -*- mode: org; -*-

* TODO [#A] Functions & variables [3/6]
A function can be parametrised by variables as well as functions.
Easiest way to achieve type agnostic expression is by inheriting
from the same base class.

- [X] Function base class implementation options: purely virtual, only
  determines interface (methods).  Use
  - polymorphism (abstract base class),
  - templated function pointer for more flexible functions?
- [X] Function class: the most generic function.  Data members:
  - function pointer,
  - vector of base class pointers as arguments to function.
- [X] Variables (parameters/observables) are linear functions.
  Possible underlying datastructures:
  - inherit directly from base class: a double, or vector of 1 double,
  - inherit from function: linear function with a double (overkill?).
  - Final: Use separate class with a double.
- [ ] Types of variables: value, category, boolean
  - category: derive from =function_base= or =function=?  The latter
    seems more natural.
- [ ] Constants:
  - variables with 0 range (min = max = val),
  - variables bound to values (=boost::bind=).
- [ ] Function pointer implementation:
  - Fixed signature: (number of args, arg array), (vector of args).
  - Different signatures, (arg1, arg2, ...) but overloaded with
    =boost::make_overloaded_function()= to a standard interface.

** TODO [#A] Hide use of shared pointers
Do not take function parameters as pointers.  Make copies inside the
constructor.

* TODO [#A] Operators [0/2]
** TODO Mathematical operators [4/6]
Global mathematical operator overloads:
- [X] assignment: =operator==,
- [X] addition & subtraction (binary): ~res = lhs +/- rhs~,
- [X] sign (unary, -ve): ~res = - obj~,
- [X] multiplication & division: ~res = lhs *// rhs~,
- [ ] multiplication & division (with doubles): ~res = num *// obj~,
- [ ] exponentiation: =operator^= (okay since bitwise OR isn't
  defined).

** TODO Comparison operators
It is not clear what should be the implementation for comparison
operators: equal to, less than, or geater than.  Memory level
comparisons are provided by pointer/reference comparisons, or
dependency tree comparison.

Which of the following make more sense:
- scan range, or
- evaluate at point.

* TODO [#B] Integrals [0/2]
** TODO Analytical integration
- Ask for function objects for integrands, and integrals.
- Each integral associated with a set of integration variables.

** TODO Numerical integration
- GSL
- ROOT
- Boost.Numeric.Odeint
- All of the above as user configurable backends?

* TODO [#A] Testing [1/2]
  :LOGBOOK:
  - State "DONE"       from "TODO"       [2013-10-17 Thu 22:34] \\
    C++ testing switched to Boost.Test.
  :END:
- [X] Boost.Test
- [ ] Python: =unittest=

* TODO [#C] Caching
- Hash the component-tree.
  - Should be possible to update only modified branches of the tree.
  - Look at git tree objects for ideas.
- Caveat: hash function should be faster than evaluation.

* TODO [#C] Fitter
Use generic TFitter to build an interface to Minuit.

* TODO [#C] Logging
Boost.Log

** Debugging tools
Need tools that can take objects and print (to file or stdout)
dependency information.  The dependency tree traversal should be both
ways: dependants as well as dependencies.  Maybe limit to one hop, or
ask for number of hops when instantiating the debugger.

* TODO [#C] Bindings
Boost.Python
